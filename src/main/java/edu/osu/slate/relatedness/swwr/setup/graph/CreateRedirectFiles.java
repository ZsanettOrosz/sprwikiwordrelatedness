package edu.osu.slate.relatedness.swwr.setup.graph;

import java.io.*;
import java.util.*;

import edu.osu.slate.relatedness.swwr.data.graph.IDVertexTranslation;

import it.unimi.dsi.fastutil.objects.*;
import it.unimi.dsi.fastutil.ints.*;

/**
 * This program generates the redirect file for the Wikipedia structure.
 * <p>
 * The inputs to this program are two Wikipedia files (redirect.sql and page.sql) and the name of a .vid file (previously generated using {@link wwr.init.graph.CreateValidIDFile}.
 * <p>
 * The output of this program is a .rdr file containing two integer array objects (from[]) (to[]).  This file is used to construct a {@link IDVertexRedirect.data.RedirectList} object.
 * <p>
 * <b>usage:</b> java CreateValidIDFile HVMCT redirectfile pagefile vidfile outputfile
 * <p>
 * <i>General Options:</i>
 * <UL>
 * <LI>[H] Print Help (this information)
 * <LI>[V] Verbose Output
 * </UL>
 * <i>Namespace Options:</i> (at least one of these must be specified)
 * <UL>
 * <LI>[M] Include Main Namespace
 * <LI>[C] Include Category Namespace
 * <LI>[T] Include Template Namespace
 * </UL>
 * <i>File Names:</i>
 * <UL>
 * <LI>[redirectfile] Input redirect.sql file
 * <LI>[pagefile] Input page.sql file
 * <LI>[vidfile] Input .vid file
 * <LI>[outputfile] Output .rdr file
 * </UL>
 * 
 * Requires the <a href="http://fastutil.dsi.unimi.it/">fastutil</a> jar be installed in the classpath.
 * @author weale
 * @version 1.0;alpha
 *
 */
public class CreateRedirectFiles {
  
  /* Appropriate Namespaces */
  private static TreeSet<String> ns;

  /* Verbose output flag */
  private static boolean verbose;
  
  /* Name of the input file generated by Wikipedia (redirect.sql) */
  private static String redirectFileName;

  /* Name of the input file generated by Wikipedia (page.sql) */
  private static String pageFileName;

  /* Name of the Valid ID file generated by CreateValidIDFile (.vid) */
  private static String vidFileName;

  /* Name of the output file (.rdr) */
  private static String outputFileName;
  
  private static String baseDir, sourceDir, binaryDir, tempDir;
  private static String type, date, graph;
  
  private static void parseConfigurationFile(String filename)
  {
    try {
      Scanner config = new Scanner(new FileReader(filename));
      sourceDir = "source";
      binaryDir = "binary";
      tempDir = "tmp";
      while(config.hasNext()) {
        String s = config.nextLine();
        if(s.contains("<basedir>")) {
          baseDir = s.substring(s.indexOf("<basedir>") + 9, s.indexOf("</basedir>"));
        }
        else if(s.contains("<sourcedir>")) {
          sourceDir = s.substring(s.indexOf("<sourcedir>") + 11, s.indexOf("</sourcedir>"));          
        }
        else if(s.contains("<binarydir>")) {
          binaryDir = s.substring(s.indexOf("<binarydir>") + 11, s.indexOf("</binarydir>"));
        }
        else if(s.contains("<tempdir>")) {
          tempDir = s.substring(s.indexOf("<tempdir>") + 9, s.indexOf("</tempdir>"));
        }
        else if(s.contains("<type>")) {
          type = s.substring(s.indexOf("<type>") + 6, s.indexOf("</type>"));
        }
        else if(s.contains("<date>")) {
          date = s.substring(s.indexOf("<date>") + 6, s.indexOf("</date>"));
        }
        else if(s.contains("<graph>")) {
          graph = s.substring(s.indexOf("<graph>") + 7, s.indexOf("</graph>"));
        }
      }
    }
    catch (IOException e) {
      System.err.println("Problem reading from file: " + filename);
      System.exit(1);
    }
    
    redirectFileName = "";
    pageFileName = "";
    vidFileName = "";
    outputFileName = "";
  }//end: parseConfigurationFile()
	
 /**
  * This method checks the command-line parameters for proper formatting.
  * <p> 
  * If the parameters aren't properly formatted, the usage information is printed to the screen
  * and the program exits. Otherwise, the filenames and input flags are set and execution
  * begins.
  * 
  * @param args Input arguments containing command-line parameters
  */
  private static void checkFlags(String [] args) {
    if(args.length != 5 || args[0].indexOf('H') != -1) {
      printUsage();
      System.exit(1);
    }
    
    //Set Verbose Flag
    verbose = (args[0].indexOf('V') != -1);
    
    //Set Namespaces
    ns = new TreeSet<String>();
    if(args[0].indexOf('M') != -1) {
      ns.add("0");
    }
    if(args[0].indexOf('C') != -1) {
      ns.add("14");
    }
    if(args[0].indexOf('T') != -1) {
      ns.add("10");
    }
		
    //Set File Names
    redirectFileName = args[1];
    pageFileName = args[2];
    vidFileName = args[3];
    outputFileName = args[4];
  }
	
 /**
  * Prints the help text to the screen
  */
  private static void printUsage() {
    System.out.println("usage: java CreateTitleFiles HVMCT redirectfile pagefile vidfile outputfile");
    System.out.println();
    System.out.println("General Options:");
    System.out.println("[H] Print Help (this information)");
    System.out.println("[V] Verbose Output");
    System.out.println();
    System.out.println("Namespace Options: (at least one of these must be specified)");
    System.out.println("[M] Include Main Namespace");
    System.out.println("[C] Include Category Namespace");
    System.out.println("[T] Include Template Namespace");
    System.out.println();
    System.out.println("File Names:");
    System.out.println("[redirectfile] Input redirect.sql file");
    System.out.println("[pagefile] Input page.sql file");
    System.out.println("[vidfile] .vid file generated by CreateValidIDFile");
    System.out.println("[outputfile] Output .rdr file");
  }
	
 /**
  * Runs the program.
  * 
  * @param args Command-line parameters
  */
  public static void main(String [] args) throws Exception {
    
    checkFlags(args);
    
    //"/scratch/weale/data/source/20080103/enwiki-20080103-redirect.sql"
    //"/scratch/weale/data/source/20080103/enwiki-20080103-page.sql"
    //"/scratch/weale/data/binary/enwiki-20080103-M.vid"
    //"/scratch/weale/data/binary/enwiki-20080103-M.rdr"
    
   /* STEP 1
    * 
    * Read all titles that must be redirected.
    */
    Scanner in = new Scanner(new FileReader(redirectFileName));
    
    // Contains X
    Object2IntAVLTreeMap<String> titleToIDMap = new Object2IntAVLTreeMap<String>();
    
    // Contains a list of the IDs to redirect
    IntAVLTreeSet IDsToRedirect = new IntAVLTreeSet();
		
    String str = in.nextLine();
    while(str.indexOf("INSERT INTO") == -1)
    {
      str = in.nextLine();
    }
	    
    while(str != null && !str.trim().equals("")) {
      str = str.substring(str.indexOf("(")+1, str.length()-3);

      // Split the String into the page information
      String [] arr = str.split("\\),\\(");
      for(int i = 0; i < arr.length; i++)
      {
        String [] info = arr[i].split(",");
	    	  
        // Check if the information is in the correct format
        if(info.length >= 3) {
		    	  
          // Extract Namespace Information
          String namespace = info[1];
		          
          String title = info[2];
          for(int j=3; j<info.length;j++){
            title = title + "," + info[j];
          }
		          
          // Add the title if it's in the main namespace
          if(namespace.equals("0")) {
            IDsToRedirect.add(Integer.parseInt(info[0]));
            titleToIDMap.put(title, -1);
          }
        }//end: if(info.length)
      }//end: for(i)
    
      str = in.nextLine();
    }//end: while()
    in.close();
		
   /* STEP 2
    * 
    * Find the IDs for the redirect titles.
    */
    in = new Scanner(new FileReader(pageFileName));
		
    str = in.nextLine();
    while(str.indexOf("INSERT INTO") == -1)
    {
      str = in.nextLine();
    }
	    
    while(str != null && !str.trim().equals("")) {
      str = str.substring(str.indexOf("(")+1, str.length()-3);

      // Split the String into the page information
      String [] arr = str.split("\\d\\),\\(");
      for(int i = 0; i < arr.length; i++)
      {
        String [] info = arr[i].split(",");
	    	  
        // Check if the information is in the correct format
        if(info.length >= 11) {
		    	  
          // Extract page, namespace and redirect information
          int ID = Integer.parseInt(info[0]);
          String namespace = info[1];
		          
          String title = info[2];
          for(int j = 3; j < info.length - 8; j++){
            title = title + "," + info[j];
          }
		          
		          
          // Add the ID if it's in the needed namespace and not a redirect
          if(namespace.equals("0") && titleToIDMap.containsKey(title)) {
            titleToIDMap.put(title, ID);
          }
        }//end: if(info.length)
      }//end: for(i)
	      
      str = in.nextLine();
    }//end: while()
    in.close();
	    
   /* STEP 3
    * 
    * Open the valid IDs for processing
    */
	IDVertexTranslation vids = new IDVertexTranslation(vidFileName);
		
   /* STEP 4
    * 
    * Open redirect file and resolve Title->ID pairs.
    * 
    * All pairs should be in the following form: (Redr -> Redr U Vld)
    */
	Int2IntAVLTreeMap IDToIDRedirect = new Int2IntAVLTreeMap();
	in = new Scanner(new FileReader(redirectFileName));
		
	str = in.nextLine();
	while(str.indexOf("INSERT INTO") == -1)
	{
	  str = in.nextLine();
	}
	    
	while(str != null && !str.trim().equals(""))
	{
	  str = str.substring(str.indexOf("(")+1, str.length()-3);

	  // Split the String into the page information
	  String [] arr = str.split("\\),\\(");
	  for(int i = 0; i < arr.length; i++)
	  {
	    String [] info = arr[i].split(",");
	    	  
	    // Check if the information is in the correct format
	    if(info.length >= 3) {
		    	  
	      // Extract page, namespace and redirect information
	      int sourceID = Integer.parseInt(info[0]);
	      String namespace = info[1];
	      
	      String title = info[2];
	      for(int j = 3; j < info.length; j++)
	      {
	        title = title + "," + info[j];
	      }
	      
	      int destID = titleToIDMap.getInt(title);
		          
	      // Add the mapping if:
	      //   * Mapping is in the main namespace
	      //   * Source ID is a redirect ID (given)
	      //   * Destination ID is a valid ID or a redirect ID
	      if( namespace.equals("0") &&
	        (vids.isValidWikiID(destID) || IDsToRedirect.contains(destID)))
	      {
	        IDToIDRedirect.put(sourceID, destID);
	      }
	    }//end: if(info.length)
	  }//end: for(i)

	  str = in.nextLine();
	}//end: while()
	in.close();
		
   /* STEP 5
    * 
    * Given ID to ID redirects, follow and converge the destination IDs
    * to a valid graph vertex (if possible).
    */
	boolean converged = false;
	Int2IntAVLTreeMap temp = (Int2IntAVLTreeMap) IDToIDRedirect.clone();
	
	while(!converged)
	{
	  converged = true;
	  
	  ObjectSortedSet<Map.Entry<Integer, Integer>> oss = temp.entrySet();
	  ObjectBidirectionalIterator<Map.Entry<Integer, Integer>> it = oss.iterator();
	  
	  while(it.hasNext())
	  {
	    Map.Entry<Integer, Integer> me = it.next();
	    int sourceID = me.getKey();
	    int destID = me.getValue();
	    
	    if( !vids.isValidWikiID(destID) )
	    { // Destination ID is not a vertex graph
	      converged = false;
		    			
	      if(sourceID == destID)
	      {
	        // Self-redirect
	        temp.remove(sourceID);
	      }
	      
	      else if(IDToIDRedirect.get(destID) == IDToIDRedirect.defaultReturnValue())
	      {
	        // Redirect is not listed, or not in-scope of the graph
	        temp.remove(sourceID);
	      }
	      else
	      {
	        // Redirect is valid, update list w/ new redirect value.
	        temp.put(sourceID, IDToIDRedirect.get(destID));
	      }
	    }
	  }//end: while(it)
	  IDToIDRedirect = (Int2IntAVLTreeMap) temp.clone();
	}//end: while(!converged)

   /* STEP 6
    * 
    * Create output arrays
    */
	int[] IDs = new int[IDToIDRedirect.size()];
	int[] vertices = new int[IDToIDRedirect.size()];
	int i = 0;
	    		
	ObjectSortedSet<Map.Entry<Integer, Integer>> oss = IDToIDRedirect.entrySet();
	ObjectBidirectionalIterator<Map.Entry<Integer, Integer>> it = oss.iterator();
	while(it.hasNext())
	{
	  Map.Entry<Integer, Integer> me = it.next();
	  IDs[i] = me.getKey();
	  vertices[i] = vids.getVertex(me.getValue());
	  i++;
    }

   /* STEP 7
    * 
    * Write objects to output file.
    */
	ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(outputFileName));
	out.writeObject(IDs);
	out.writeObject(vertices);
	out.close();
  }
}
